 

Для использования MAX7219 в качестве драйвера матрицы, нужно инициализировать микросхему:

1. Записать в регистр 0xX9 (Mode Decode) значение 0x00
2. Записать в регистр 0xXB (Scan Limit) "порядок матрицы" - 1. В нашем случае это 8-1=7.
3. Записать в регистр 0xXA  (Intensivity) значение интенсивности свечения от 0x00 до 0xFF.
4. Записать в регистр 0xXC  (Power) значение 0x01 - включить матрицу.

 

А потом через SPI записывать в регистры 16-ти битное слово, которое, соответственно, подает в X-столбец (аналог 

DIG, катод) 8 бит (аналог SEGA-F,DP, анод).

 



 

Далее мы итеративно сдвигаем данные на 1 влево и дописываем в начало новые.

 

К примеру, буква "K".

 



 

Представляется как матрица 6x8
0b11111110, 0b00010000, 0b00101000, 0b01000100, 0b10000010, 0b00000000

 

Алгоритм отображения:
1. В столбец X0 пишется i-ое число 0b11111110.
2. Сдвиг всех столбцов на 1 влево.
3. В столбец X0 пишется i+1-ое число 0b00010000.
И так далее по кругу.

 

Пример кода для Atmega8:

#define F_CPU 1000000UL
#include "max7219.h"

 

int main(void)
{ 
   uint8_t words[] =   
        { 0b11111110, 0b00010000, 0b00101000, 0b01000100, 0b10000010, 0b00000000,//K
          0b11111110, 0b10010010, 0b10010010, 0b10010010, 0b10000010, 0b00000000,//E
          0b11111110, 0b10010000, 0b10010000, 0b10010000, 0b01101110, 0b00000000,//R
          0b11111110, 0b01000000, 0b00100000, 0b00010000, 0b11111110, 0b00000000,//N
          0b11111110, 0b10010010, 0b10010010, 0b10010010, 0b10000010, 0b00000000,//E
          0b11111110, 0b00000010, 0b00000010, 0b00000010, 0b00000010, 0b00000000,//L
          0b00000010, 0b00000000, //.
          0b11111110, 0b10010000, 0b10010000, 0b10010000, 0b01100000, 0b00000000,//P
          0b11111110, 0b10010000, 0b10010000, 0b10010000, 0b01101110, 0b00000000,//R
          0b01111100, 0b10000010, 0b10000010, 0b10000010, 0b01111100, 0b00000000,//O
          0b00000000, 0b00000000, 0b00000000, 0b00000000
        };


   uint8_t count_matrix = 1;//количество матриц
   uint8_t wh_matrix = 8;//размерность матрицы
   uint8_t buf_lenght = count_matrix*wh_matrix;//длина буфера
   uint8_t buf[buf_lenght];//буфер хранения (кольцевой)
   MAX7219_init(MAX7219_MANUAL, wh_matrix, count_matrix);

 

   while(1) {
   MAX7219_passNullDisplay();
   for (uint8_t x = 0; x<sizeof(words); x++)
   {
      for (uint8_t bb = 0; bb<buf_lenght-1;bb++)
      {
         buf[bb]=buf[bb+1];
      }
      buf[buf_lenght-1] = words[x];
      
      for (uint8_t pos_clmn = 0; pos_clmn<wh_matrix; pos_clmn++)
      {
         MAX7219_LOAD0;
         for (uint8_t num_mtrx = 0; num_mtrx<count_matrix; num_mtrx++)
         {
            MAX7219_write_customData(wh_matrix-(pos_clmn), buf[pos_clmn+(wh_matrix*num_mtrx)]);
         }
         MAX7219_LOAD1;
         #ifdef HWSPI
         _delay_ms(15);
         #endif         
      }      
   }
            }

}

